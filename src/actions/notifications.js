import { ToastAndroid } from 'react-native';
import PushNotification from 'react-native-push-notification';
import DeviceInfo from 'react-native-device-info';

import { REQUESTS } from './api';
import callApi from './api';

import {
  PUSH_NOTIFICATION_ASKED,
  PUSH_NOTIFICATION_SHOULD_ASK,
  PUSH_NOTIFICATION_SET_TOKEN,
  PUSH_NOTIFICATION_REMINDER,
} from '../constants';
import { isAndroid } from '../utils/common';


export function disableAskPushNotification() {
  return {
    type: PUSH_NOTIFICATION_SHOULD_ASK,
    bool: false,
  };
}

export function enableAskPushNotification() {
  return {
    type: PUSH_NOTIFICATION_SHOULD_ASK,
    bool: true,
  };
}

export function noNotificationReminder(showReminder = false) {
  return {
    type: PUSH_NOTIFICATION_REMINDER,
    bool: showReminder,
  };
}

export function setupPushNotifications() {
  return (dispatch, getState) => {
    const { token, shouldAsk, isRegistered } = getState().notifications;
    if (!shouldAsk) return;
    console.warn(token, isRegistered);
    // TODO: Remove this when testing notification callback
    // Don't bother getting this stuff if there is already a token
    if (token && isRegistered) {
      return;
    }

    LOG('asking for push notification token');

    PushNotification.configure({
      // (optional) Called when Token is generated (iOS and Android)
      onRegister(token) {
        dispatch({ type: PUSH_NOTIFICATION_SET_TOKEN, token: token.token });
        //make api call to register token with user
        dispatch(registerPushDevice(token.token));
      },
      // (required) Called when a remote or local notification is opened or received
      onNotification(notification) {
        let state;
        if (notification && notification.foreground && !notification.userInteraction) {
          state = 'foreground';
        } else if (notification && !notification.foreground && !notification.userInteraction) {
          state = 'background';
        } else {
          state = 'open';
        }
        dispatch(handleNotifications(state, notification));
      },
      // ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
      // senderID: CONSTANTS.GCM_SENDER_ID,

      // IOS ONLY (optional): default: all - Permissions to register.
      permissions: {
        alert: true,
        badge: true,
        sound: true,
      },
      // Should the initial notification be popped automatically
      // default: true
      popInitialNotification: true,
      /**
      * (optional) default: true
      * - Specified if permissions (ios) and token (android and ios) will requested or not,
      * - if not, you must call PushNotificationsHandler.requestPermissions() later
      */
      requestPermissions: true,
    });

    if (!getState().notifications.hasAskedPushNotification) {
      dispatch({ type: PUSH_NOTIFICATION_ASKED });
    }
  };
}


export function registerPushDevice(token) {
  return (dispatch) => {
    const type = DeviceInfo.getManufacturer();
    const data ={
      data: {
        type: 'push_notification_device_token',
        attributes: {
          token,
          platform: type === 'Apple' ? 'APNS' : 'GCM',
        },
      },
    };

    return dispatch(callApi(REQUESTS.SET_PUSH_TOKEN, {}, data)).then((r)=>WARN('results',r)).catch((error) => {
      WARN('error setting push token', error);
    });
  };
}

export function handleNotifications(state, notification) {
  return () => {
    LOG('Notification state', state, notification);
  };
}


export function scheduleNotification(date, data) {
  return (dispatch, getState) => {
    const token = getState().notifications.token;
    LOG('date, data, token', date, data, token);
    // PushNotification.localNotification({
    //   date,
    //   /* Android Only Properties */
    //   id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
    //   ticker: 'My Notification Ticker', // (optional)
    //   autoCancel: true, // (optional) default: true
    //   largeIcon: 'ic_launcher', // (optional) default: 'ic_launcher'
    //   smallIcon: 'ic_notification', // (optional) default: 'ic_notification' with fallback for 'ic_launcher'
    //   bigText: 'My big text that will be shown when notification is expanded', // (optional) default: 'message' prop
    //   subText: 'This is a subText', // (optional) default: none
    //   color: 'red', // (optional) default: system default
    //   vibrate: true, // (optional) default: true
    //   vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
    //   tag: 'some_tag', // (optional) add tag to message
    //   group: 'group', // (optional) add group to message
    //   ongoing: false, // (optional) set whether this is an "ongoing" notification

    //   /* iOS only properties */
    //   // alertAction: // (optional) default: view
    //   // category: // (optional) default: null
    //   // userInfo: // (optional) default: null (object containing additional notification data)

    //   /* iOS and Android properties */
    //   title: 'My Notification Title', // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
    //   message: 'My Notification Message', // (required)
    //   playSound: false, // (optional) default: true
    //   soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
    //   number: '10', // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
    //   repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
    //   actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
    // });
  };
}

export function clearAllScheduledNotifications() {
  return () => {
    PushNotification.cancelAllLocalNotifications();
  };
}

export function toast(text, duration) {
  return () => {
    if (isAndroid) {
      const toastDuration = duration === 'long' ? ToastAndroid.LONG : ToastAndroid.SHORT;
      ToastAndroid.show(text, toastDuration);
    }
  };
}
